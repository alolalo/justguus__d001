---
title: Test like the Q-wind!
date: 2022-04-08T10:33:53.481Z
author: Guus "mr Bot" Hoeve
summary: A single responsibility test-utility, using only ONE css variable; var(--q);
metaDescription: "Q-wind is an experimental approach to testing using one single
  variable to test everything. "
tags:
  - CSS
  - DS
  - DX
---
# Qwind.css

# Revolver-DS

# Lock.css

# Load.css

# Ship.css

# Reset.css

# Preset.css

# Hello Guus!

Hi, I'm justgu.us and this is my attempt at shaking up and waking up some designers & developers, *especially* copywriters too, to practice some "new CSS" because... 

I'm writing my blogposts in reverse-ordering; I first show you all the goodies, what you came for, and than talk for ages on my "why's", what I came for; writing.

This part of the blogpost is therefor mostly for me, as a viewer experience of myself. And others can read it too as a bonus.

##### In defense of Programming

CSS itself is just awesome as a **prototyping & testing** tool for your design to final code steps! That to me sounds a lot like... programming!

Especially if you're new to CSS, a testing-library to see where all things are placed (or even working!) is quite nice! That's a program, not a stylesheet imo.

So instead of breaking things in production-ready libraries, I decided to break away from that idea and just isolate a single purpose; testing

It seperates two things gracefully; the fact I can ruin development assets that they want to protect so preciously per repository, and the fact I can test those artifacts by the facts they don't meet their own standards.

Not in post production; **preproduction** testing, when you're setting things up so you don't have to check them after the fact; you know because you tested it first!

And so Q-Wind was born in a way of simplicity-first; one form, one function, one fiction of purpose. To test designs before the fact they need to be tested in the front-end.

It's always far less expensive to test and prevent things upfront, ask your local fire department. 

So that goes too in code, where designers now face a layer of code they normally don't WANT to see. But as you can see they can easily layer their work around their developers work.

It's a missed opportunity if we want to see designers code, because what you ask of them is to code like you. Ask HOW would designers code, and you will see they have a different approach from the surface.

##### Press SPACE, designers

See most people probably don't get the origin of `code;` it's a language, not a production-ready standard to comply with from the start. Most developers don't get this too.

Testing is production too, it's very easy and therefor also very hard to forget, and it doesn't just happen in the front-end. 

Testing sounds much like insurance, but what it mostly will be used for is checking up on standards that need to be met. But that checklist is always left to the end.
 
And if you do only test at the end, you did it too late imo and most likely you are not a designer. You need to ask why they don't test their designs!

An illusion of mind, created by framing & naming testing environments. Like if you don't do it in an "environment", all hell brakes lose

And in respect to the incompleteness theorem; developers really suck at visually explaining how literal, relative and lateral their code works.

See, I just think the whole idiom of designers who "need to code" is a FAD of self-invented luxury that design tools offer them to escape to these days, and that developers keep them in these days.

The "Big Devide" or "Big Gap" that people are talking about is nothing more to me than the inability of people caught up in their own idea of what is "technology".

Designers don't think visually, they just see the surface. That's why they think visually! If they would see code, would they than magically transform into a unicorn?

They just don't want to code, they want to drag & drop code on a canvas... Like that's some form of programming they are entitled too, and others should fix it for them.

Again, they see the surface because that's the only thing they can see. A code editor is also a surface, for reading code and changing it's design, the word, on the fly.

I can assure you, there are great tools out there that can do just that; drag & drop a few shiny things for you on a canvas. 

But then you just think you're a front-end dev because of the result, not because of what you did. And without the tool, would you be as great?

Simply because you see the surface doesn't mean you understand the engine like a professional. 

If I would then be the designer of your team, or even a corporate, I would opt for 100% user generated design. 

If you can do drag & drop, so can they right? Let the user fix the UI for themselves with some blocks!

And then you would come to the true problem of why frameworks don't work; you only added a layer on top of the layer that was sufficient enough; the end-user.

Why would you have a FT employee do just that, drag & drop, if you can have people do that for free while they have fun too! 

Look at Blender for that matter, an open-source tool that has survived and thrived for 25+ years on the community alone.

See, the only times you see that kind of UI working for your kind of work is once in a lifetime, or we would have settled on best practices by now.

And for more than half a century, a text-editor has always been good enough to create those awesome coded things you and I interact with everyday. 

A legacy, yes, but one that will stay for a long, long time since language is the main driver behind it's technology. Nothing can be smaller than that, and zero's and one's are just smallest bit language you can fit in.

Naming things becomes framing things, and if you still see me as a designer but still haven't figured out "how I do it", it's because I'm not that title to begin with; a designer, a developer, a programmer.

That's why I branded myself justgu.us, to undo the framing and gaming of self-imposed supremecy in tech. Like if a title would boost my IQ, competence or confidence. 

As if any more would do good for people's judge of character. No, people get judged by job-title.

That's also great for me because my job-title is justgu.us, and I'm there; not they/them but fully self-aware.

I also did it to protect a certain identity, voice & ownership I think anyone should have; your name. 

What's yours is yours, what's mine is mine. My name especially, you didn't give that (back) to me rolled in your shitstains.

And since I now use my name as my title, I don't want any other job title because they simply make me sound boring! Really, just once you see the UX of things; 

Any questions? Just askgu.us
See more? Just followgu.us
Who are you? justgu.us

You see, how can any job title compete with that?! You would simply lose value by giving me a title! I win, you win, game over... No more job titles, just professional people!

Naming things is important, and if you've made your own name a brand identity that in the literal sense represents you as a professional, you better back it up or your name didn't mean anything to no one; not even yourself.

I had the highest of highest education, but I never needed to waiver a paper to make a point. The point is that language is a technology itself, and I was born to write.

Titles don't show people's ambition or competence, only their supposed responsibility & authority. But they are static and not dynamic declarations of power, or they wouldn't be asking for the pay-raise to begin with.

And the only job-title I have is to just be me and do what I'm good at; creating co-operative systems of dynamic & fluid design for the armies of one, and the many.

As a (game) designer I write design rules in the CSS programming language based on my design system's layered architecture & naming; Lock, Load & Ship!

Today I don't use the cascade anymore to explain how it works, or specificity; I think of it already like Photoshop now, with layers of "watering down" the rendering.

I talk in a more kinetical way of how things move inside the system, and how we relate to them on the metaphorical plane. 

The analogy of a river has always resonated with programmers, trees too. Natural language is key then.

CSS uses @layers now that will make you feel right at home coming from any graphical application, except this is how a developer layers their artwork; using a CS language because it needs to be automated. 



### Language as a system

I intentionally mentioned I'm a game designer here, as games are closed systems of feed-forward and feed-back to not only the player-space (UX) but also the maker-space (DX). 

They apply the right kind of restrictions to allow the movement and freedom within the space. You think you can do anything in a modern game, but it's the opposite actually; it's how far the makers got to creating the illusion of it.

How it's made is not how it's sold...

##### A word about CSS

And that is what this post is actually about; what if **the word CSS** was invented to refer to "Closed System Strategy", in which the purpose is to create a closed system of design. Much like a videogame.

Yes, it's a horrible name new abbreviation for CSS. Yes, it doesn't sound sexy. Yes, it will even create a bigger feeling of nerdy disgust to say " Why are you using Closed Styled Strategy and not React+Emotion?"

Comparing CSS with React to begin with is comparing apples & pears these days, not because they are neither good or bad, or that they are a programming language (they are standards);

It's because everyone still sees CSS as a "cascading style sheet", and those words never seem to bother anyone as a "source of evil" on why CSS is frowned and looked down upon...

To me CSS a functional programming language, that **I LOVE** learning, at the moment for layering and watering down your design choices and rules, so the browser can know what to do when it's context shifts. 

It's the only programming language specifically driven by design, for design. It is also the only programming language that is becoming more semantical & technical at the same time. Meaning simply; easier to read.

That right there is what the true value of a good programming language sets all others apart; can you read it, without knowing about it?

```css
  body {
    line-height: 1.6ex;
    -webkit-font-smoothing: antialiased;
    text-rendering: geometricPrecision;
  }

  p:not(.text-hidden){
    font-size: 21px;
}
```

It's very beginner-friendly in its reading experience, even if you've never seen it. And for your ease of comfort, or not; I'm just beginning to learn the "new way" that is literally a few days old historically speaking.

The newsyntax is not more complex than Excel these days, and mostly it doesn't take more than three lines of CSS to create something effective & simple.

My point is simply this; if we only say CSS is for styling, and not for programming our own closed system of styling things with the browser, I don't think people will actually get the new CSS to begin with;

You can write your own design system & language ***now!*** 

##### functional programming vs functional language

CSS as a functional programming language that enables most to program design as a rule-based system who are *not into the front-end*. 

If anything developers "hate" CSS, so why would you bother making a better system for them if designers can now "write their own"?!

No it is already enabling far more people to think outside of the falacy-box of "a programmer", which to my indigenous dutch sense of self is just another word for

I'm saying that I'm walking away from talking like some pretentiously friendly & kind developer for the sake of a better human experience.

You know, that default we constantly need to be reminded about... It's like we suffer more from our own brainwashing ourselves into humanity, but never actually show its grace.

Because naming things in code is one of the two hardest things in CS, and that's exactly why copywriters would be great programmers in the "new CSS" if you ask me.

So what am I saying? Well, we need to *relanguage CSS* a bit, because it still sounds "dusty, dirty & nerdy" to the many. Because of how it's *named & framed*.

I'm not the only one making a point about this; Ahmad Shadeed wrote about the contextual shift that we can undergo too to see CSS differently, and my take is *testing in the browser.*

It will never be production-ready because that's not what it was meant for; it was meant to make your stuff production-ready faster by seeing what is happening with --Q.